(()=>{"use strict";((e,t)=>{t.K=void 0,t.K={USER_REJECTED:{code:4001,message:"User rejected the request"},UNAUTHORIZED:{code:4100,message:"Unauthorized - not connected to MonkeyMask"},UNSUPPORTED_METHOD:{code:4200,message:"Unsupported method"},DISCONNECTED:{code:4900,message:"Provider is disconnected"},CHAIN_DISCONNECTED:{code:4901,message:"Chain is disconnected"},INVALID_PARAMS:{code:-32602,message:"Invalid method parameters"},INTERNAL_ERROR:{code:-32603,message:"Internal error"}};class n{constructor(){this._isConnected=!1,this._publicKey=null,this.connectedAccounts=[],this.requestId=0,this.pendingRequests=new Map,this.eventListeners=new Map,this.isMonkeyMask=!0,this.isBanano=!0,this.setupMessageListener(),this.setupProviderEventListener(),this.attemptSilentReconnection()}get isConnected(){return this._isConnected}get publicKey(){return this._publicKey}on(e,t){this.eventListeners.has(e)||this.eventListeners.set(e,new Set),this.eventListeners.get(e).add(t)}off(e,t){const n=this.eventListeners.get(e);n&&(n.delete(t),0===n.size&&this.eventListeners.delete(e))}removeAllListeners(){this.eventListeners.clear()}emit(e,...t){const n=this.eventListeners.get(e);n&&n.forEach(e=>{try{e(...t)}catch(e){console.error("BananoProvider: Error in event handler:",e)}})}async attemptSilentReconnection(){try{console.log("BananoProvider: Attempting silent reconnection..."),await new Promise(e=>setTimeout(e,500));const e=await this.sendMessage("CHECK_CONNECTION");e.isConnected?(console.log("BananoProvider: Silent reconnection successful:",e.publicKey),this._isConnected=!0,this._publicKey=e.publicKey,this.connectedAccounts=e.accounts||[e.publicKey],this.emit("connect",{publicKey:e.publicKey})):console.log("BananoProvider: No existing connection found for this origin")}catch(e){console.log("BananoProvider: Silent reconnection failed:",e instanceof Error?e.message:"Unknown error")}}setupMessageListener(){window.addEventListener("message",e=>{if(e.source===window&&e.data&&"banano-provider-response"===e.data.source){const{id:t,response:n}=e.data,s=this.pendingRequests.get(t);if(s)if(this.pendingRequests.delete(t),n.success)s.resolve(n.data);else{const e=this.createProviderError(n.error,n.code);s.reject(e)}}})}setupProviderEventListener(){window.addEventListener("message",e=>{if(e.source===window&&e.data&&"banano-provider-event"===e.data.source){const{event:t,data:n}=e.data;switch(t){case"connect":this._isConnected=!0,this._publicKey=n.publicKey,this.connectedAccounts=n.accounts||[],this.emit("connect",n);break;case"disconnect":this._isConnected=!1,this._publicKey=null,this.connectedAccounts=[],this.emit("disconnect");break;case"accountChanged":this._publicKey=n.publicKey,this.connectedAccounts=n.accounts||[],this.emit("accountChanged",n.publicKey)}}})}createProviderError(e,n){const s=new Error(e);return s.code=n||t.K.INTERNAL_ERROR.code,s}async sendMessage(e,n={}){return new Promise((s,o)=>{const i=++this.requestId;this.pendingRequests.set(i,{resolve:s,reject:o}),window.postMessage({source:"banano-provider",id:i,type:e,...n},"*");let c=3e4;"SEND_TRANSACTION"===e||"SIGN_MESSAGE"===e||"SIGN_BLOCK"===e||"SEND_BLOCK"===e?c=9e5:"CONNECT_WALLET"===e&&(c=3e5),setTimeout(()=>{if(this.pendingRequests.has(i)){this.pendingRequests.delete(i);const e=this.createProviderError("Request timeout",t.K.INTERNAL_ERROR.code);o(e)}},c)})}async connect(e){try{console.log("BananoProvider: Connecting with options:",e);const n=await this.sendMessage("CONNECT_WALLET",{options:e});if(this._isConnected=!0,this._publicKey=n.publicKey||n.address,this.connectedAccounts=n.accounts||[this._publicKey],!this._publicKey)throw this.createProviderError("No public key received from wallet",t.K.INTERNAL_ERROR.code);return console.log("BananoProvider: Connected with publicKey:",this._publicKey),this.emit("connect",{publicKey:this._publicKey}),{publicKey:this._publicKey}}catch(e){if(console.error("BananoProvider: Connect failed:",e),e instanceof Error&&e.code)throw e;throw this.createProviderError("Failed to connect to MonkeyMask",t.K.INTERNAL_ERROR.code)}}async disconnect(){try{await this.sendMessage("DISCONNECT_WALLET"),this._isConnected=!1,this._publicKey=null,this.connectedAccounts=[],this.emit("disconnect"),console.log("BananoProvider: Disconnected")}catch(e){console.error("BananoProvider: Disconnect failed:",e),this._isConnected=!1,this._publicKey=null,this.connectedAccounts=[],this.emit("disconnect")}}async getAccounts(){if(!this._isConnected)throw this.createProviderError("Not connected to MonkeyMask. Call connect() first.",t.K.UNAUTHORIZED.code);return console.log("BananoProvider: Returning accounts:",this.connectedAccounts),[...this.connectedAccounts]}async signMessage(e,n="utf8"){if(!this._isConnected)throw this.createProviderError("Not connected to MonkeyMask",t.K.UNAUTHORIZED.code);if(!this._publicKey)throw this.createProviderError("No public key available",t.K.INTERNAL_ERROR.code);try{let t;console.log("BananoProvider: Signing message with display:",n),t=e instanceof Uint8Array?Array.from(e).map(e=>e.toString(16).padStart(2,"0")).join(""):e;const s=await this.sendMessage("SIGN_MESSAGE",{message:t,display:n,publicKey:this._publicKey});return{signature:new Uint8Array(s.signature.match(/.{2}/g).map(e=>parseInt(e,16))),publicKey:this._publicKey}}catch(e){if(console.error("BananoProvider: Sign message failed:",e),e instanceof Error&&e.code)throw e;throw this.createProviderError("Failed to sign message",t.K.INTERNAL_ERROR.code)}}async verifySignedMessage(e,t,n,s="utf8"){return!!(await this.sendMessage("VERIFY_SIGNED_MESSAGE",{message:e,signature:t,publicKey:n,display:s,origin:window.location.origin})).valid}async signBlock(e){if(!this._isConnected)throw this.createProviderError("Not connected to MonkeyMask",t.K.UNAUTHORIZED.code);return this.sendMessage("SIGN_BLOCK",{block:e})}async sendBlock(e){if(!this._isConnected)throw this.createProviderError("Not connected to MonkeyMask",t.K.UNAUTHORIZED.code);return(await this.sendMessage("SEND_BLOCK",{block:e})).hash}async sendTransaction(e,n,s){if(!this._isConnected)throw this.createProviderError("Not connected to MonkeyMask",t.K.UNAUTHORIZED.code);console.log("BananoProvider: Sending transaction:",e,"->",n,s,"BAN");const o=await this.sendMessage("SEND_TRANSACTION",{fromAddress:e,toAddress:n,amount:s});return{hash:o.hash,block:o.block}}async resolveBNS(e){return console.log("BananoProvider: Resolving BNS name:",e),(await this.sendMessage("RESOLVE_BNS",{bnsName:e})).address}async getBalance(e){if(!this._isConnected)throw this.createProviderError("Not connected to MonkeyMask",t.K.UNAUTHORIZED.code);const n=e||this.connectedAccounts[0];if(!n)throw this.createProviderError("No address available",t.K.INTERNAL_ERROR.code);console.log("BananoProvider: Getting balance (via account info) for:",n);const s=await this.sendMessage("GET_ACCOUNT_INFO",{address:n});return s.accountInfo?.balance||"0"}async getAccountInfo(e){if(!this._isConnected)throw this.createProviderError("Not connected to MonkeyMask",t.K.UNAUTHORIZED.code);const n=e||this.connectedAccounts[0];if(!n)throw this.createProviderError("No address available",t.K.INTERNAL_ERROR.code);return console.log("BananoProvider: Getting account info for:",n),(await this.sendMessage("GET_ACCOUNT_INFO",{address:n})).accountInfo}}if(!window.banano){const e=new n;Object.defineProperty(window,"banano",{value:e,writable:!1,configurable:!1}),window.dispatchEvent(new CustomEvent("banano#initialized",{detail:{provider:e}}))}})(0,{})})();